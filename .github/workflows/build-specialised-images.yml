name: Build Specialised Platform Images Workflow
description: Workflow to build specialised platform images using matrix strategy

on:
  workflow_call:
    inputs:
      version:
        description: 'Platform version to build (e.g., 7.4.0)'
        type: string
        required: true
      image_types:
        description: 'JSON array of image types to build (e.g., ["base", "base-clear"])'
        type: string
        required: true
      updated_tags:
        description: 'Comma-separated list of tags to apply to multi-arch images (e.g., pre-release, latest)'
        type: string
      build_id:
        description: 'Unique build ID per workflow run'
        type: string
        required: true
      engineering_prefix:
        description: 'Engineering prefix to place multi-arch images in Harbor'
        type: string
        default: devops_sandbox_engineering
      releases_prefix:
        description: 'Releases prefix to place multi-arch images in Harbor'
        type: string
        default: devops_sandbox_releases
      is_release:
        description: 'Whether this is a pre-release or release version'
        type: string
      dev_tools_version:
        description: 'Dev tools version for devenv image build'
        type: string
    secrets:
      GH_TOKEN:
        required: true
      REGISTRY_USERNAME:
        required: true
      REGISTRY_PASSWORD:
        required: true
      HARBOR_CLI_SECRET:
        required: true
      HARBOR_USERNAME:
        required: true

run-name: Build Platform ${{ inputs.version }} Images

jobs:
  # Generate release_modules list by filtering out -clear images
  setup:
    runs-on: ubuntu-latest
    outputs:
      release_modules: ${{ steps.filter.outputs.release_modules }}
    steps:
      - name: Filter release modules
        id: filter
        run: |
          IMAGE_TYPES='${{ inputs.image_types }}'
          
          # Parse JSON array and filter out -clear images
          RELEASE_MODULES=$(echo "$IMAGE_TYPES" | jq -r '.[] | select(contains("-clear") | not) | "platform/platform-" + .' | paste -sd ',' -)
          
          # If empty, set to "none" to prevent false positives in contains() checks
          if [ -z "$RELEASE_MODULES" ]; then
            RELEASE_MODULES="none"
          fi
          
          echo "release_modules=$RELEASE_MODULES" >> $GITHUB_OUTPUT
          echo "Release modules (excluding -clear images): $RELEASE_MODULES"

  # Build architecture-specific images in parallel
  build-arch-images:
    needs: [setup]
    strategy:
      matrix:
        image_type: ${{ fromJson(inputs.image_types) }}
        architecture: [arm64, amd64]
    runs-on: ${{ matrix.architecture == 'arm64' && 'arm64' || 'x64' }}
    steps:
      - name: Determine build parameters
        id: params
        run: |
          IMAGE_TYPE="${{ matrix.image_type }}"
          
          # Determine dockerfile based on image type
          case "$IMAGE_TYPE" in
            base|base-clear)
              echo "dockerfile=dockerfile.base" >> $GITHUB_OUTPUT
              ;;
            build|build-clear)
              echo "dockerfile=dockerfile.build" >> $GITHUB_OUTPUT
              ;;
            appserver)
              echo "dockerfile=dockerfile.appserver" >> $GITHUB_OUTPUT
              ;;
            tools)
              echo "dockerfile=dockerfile.tools" >> $GITHUB_OUTPUT
              ;;
            devenv|devenv-clear)
              echo "dockerfile=dockerfile.devenv" >> $GITHUB_OUTPUT
              ;;
          esac
          
          # Determine obfuscate value
          if [[ "$IMAGE_TYPE" == *"-clear" ]]; then
            echo "obfuscate=false" >> $GITHUB_OUTPUT
          else
            echo "obfuscate=unset" >> $GITHUB_OUTPUT
          fi
          
          # Determine platform_base value
          if [[ "$IMAGE_TYPE" == "build-clear" ]] || [[ "$IMAGE_TYPE" == "devenv-clear" ]]; then
            echo "platform_base=platform/platform-base-clear" >> $GITHUB_OUTPUT
          else
            echo "platform_base=platform/platform-base" >> $GITHUB_OUTPUT
          fi

      - name: Build and push platform image
        uses: IQGeo/devops-engineering-ci-public-platform-build-push-action@main
        with:
          version: ${{ inputs.version }}
          build_id: ${{ inputs.build_id }}
          platform: ${{ matrix.architecture }}
          image_type: ${{ matrix.image_type }}
          dockerfile: ${{ steps.params.outputs.dockerfile }}
          acr: iqgeoproddev.azurecr.io
          registry_username: ${{ secrets.REGISTRY_USERNAME }}
          registry_password: ${{ secrets.REGISTRY_PASSWORD }}
          engineering_prefix: ${{ inputs.engineering_prefix }}
          gh_token: ${{ secrets.GH_TOKEN }}
          obfuscate: ${{ steps.params.outputs.obfuscate }}
          platform_base: ${{ steps.params.outputs.platform_base }}
          dev_tools_version: ${{ inputs.dev_tools_version }}

  # Create multi-arch manifests for all images
  create-multi-arch-manifests:
    needs: [setup, build-arch-images]
    strategy:
      matrix:
        image_type: ${{ fromJson(inputs.image_types) }}
    runs-on: x64
    steps:
      - name: Create multi-arch manifest
        uses: IQGeo/devops-engineering-ci-public-multi-arch-action@main
        with:
          version: ${{ inputs.version }}
          amd_tag: ${{ inputs.build_id }}_amd-64
          arm_tag: ${{ inputs.build_id }}_arm-64
          updated_tags: ${{ inputs.updated_tags }}
          module: platform/platform-${{ matrix.image_type }}
          release_modules: ${{ needs.setup.outputs.release_modules }}
          acr: iqgeoproddev.azurecr.io
          harbor: harbor.delivery.iqgeo.cloud
          registry_username: ${{ secrets.REGISTRY_USERNAME }}
          registry_password: ${{ secrets.REGISTRY_PASSWORD }}
          harbor_cli_secret: ${{ secrets.HARBOR_CLI_SECRET }}
          harbor_username: ${{ secrets.HARBOR_USERNAME }}
          engineering_prefix: ${{ inputs.engineering_prefix }}
          releases_prefix: ${{ inputs.releases_prefix }}
          is_release: ${{ inputs.is_release }}
