name: Build Specialised Platform Images Workflow
description: Workflow to build specialised platform images for a specific wave/dependency group

on:
  workflow_call:
    inputs:
      version:
        description: 'Platform version to build (e.g., 7.4.0)'
        type: string
        required: true
      wave:
        description: 'Build wave number (1=base, 2=build, 3=appserver/tools, 4=devenv)'
        type: string
        required: true
      updated_tags:
        description: 'Comma-separated list of tags to apply to multi-arch images (e.g., pre-release, latest)'
        type: string
      build_id:
        description: 'Unique build ID per workflow run'
        type: string
        required: true
      engineering_prefix:
        description: 'Engineering prefix to place multi-arch images in Harbor'
        type: string
        default: devops_sandbox_engineering
      releases_prefix:
        description: 'Releases prefix to place multi-arch images in Harbor'
        type: string
        default: devops_sandbox_releases
      is_release:
        description: 'Whether this is a pre-release or release version'
        type: string
      dev_tools_version:
        description: 'Dev tools version for devenv image build'
        type: string
    secrets:
      GH_TOKEN:
        required: true
      REGISTRY_USERNAME:
        required: true
      REGISTRY_PASSWORD:
        required: true
      HARBOR_CLI_SECRET:
        required: true
      HARBOR_USERNAME:
        required: true

run-name: Build Platform ${{ inputs.version }} Wave ${{ inputs.wave }} Images

jobs:
  # Determine which images to build based on wave
  setup:
    runs-on: ubuntu-latest
    outputs:
      image_types: ${{ steps.set-images.outputs.types }}
    steps:
      - name: Set image types for wave
        id: set-images
        run: |
          case "${{ inputs.wave }}" in
            "1")
              echo 'types=["base", "base-clear"]' >> $GITHUB_OUTPUT
              ;;
            "2")
              echo 'types=["build", "build-clear"]' >> $GITHUB_OUTPUT
              ;;
            "3")
              echo 'types=["appserver", "tools"]' >> $GITHUB_OUTPUT
              ;;
            "4")
              echo 'types=["devenv", "devenv-clear"]' >> $GITHUB_OUTPUT
              ;;
            *)
              echo "Unknown wave: ${{ inputs.wave }}"
              exit 1
              ;;
          esac

  # Build architecture-specific images
  build-arch-images:
    needs: [setup]
    strategy:
      matrix:
        image_type: ${{ fromJson(needs.setup.outputs.image_types) }}
        architecture: [arm64, amd64]
    runs-on: ${{ matrix.architecture == 'arm64' && 'arm64' || 'x64' }}
    steps:
      - name: Determine build parameters
        id: params
        run: |
          IMAGE_TYPE="${{ matrix.image_type }}"
          
          # Determine dockerfile based on image type
          case "$IMAGE_TYPE" in
            base|base-clear)
              echo "dockerfile=dockerfile.base" >> $GITHUB_OUTPUT
              ;;
            build|build-clear)
              echo "dockerfile=dockerfile.build" >> $GITHUB_OUTPUT
              ;;
            appserver)
              echo "dockerfile=dockerfile.appserver" >> $GITHUB_OUTPUT
              ;;
            tools)
              echo "dockerfile=dockerfile.tools" >> $GITHUB_OUTPUT
              ;;
            devenv|devenv-clear)
              echo "dockerfile=dockerfile.devenv" >> $GITHUB_OUTPUT
              ;;
          esac
          
          # Determine obfuscate value
          if [[ "$IMAGE_TYPE" == *"-clear" ]]; then
            echo "obfuscate=false" >> $GITHUB_OUTPUT
          else
            echo "obfuscate=unset" >> $GITHUB_OUTPUT
          fi
          
          # Determine platform_base value
          if [[ "$IMAGE_TYPE" == "build-clear" ]] || [[ "$IMAGE_TYPE" == "devenv-clear" ]]; then
            echo "platform_base=platform/platform-base-clear" >> $GITHUB_OUTPUT
          else
            echo "platform_base=platform/platform-base" >> $GITHUB_OUTPUT
          fi

      - name: Build and push platform image
        uses: IQGeo/devops-engineering-ci-public-platform-build-push-action@main
        with:
          version: ${{ inputs.version }}
          build_id: ${{ inputs.build_id }}
          platform: ${{ matrix.architecture }}
          image_type: ${{ matrix.image_type }}
          dockerfile: ${{ steps.params.outputs.dockerfile }}
          acr: iqgeoproddev.azurecr.io
          registry_username: ${{ secrets.REGISTRY_USERNAME }}
          registry_password: ${{ secrets.REGISTRY_PASSWORD }}
          engineering_prefix: ${{ inputs.engineering_prefix }}
          gh_token: ${{ secrets.GH_TOKEN }}
          obfuscate: ${{ steps.params.outputs.obfuscate }}
          platform_base: ${{ steps.params.outputs.platform_base }}
          dev_tools_version: ${{ inputs.dev_tools_version }}

  # Create multi-arch manifests for all images in this wave
  create-multi-arch-manifests:
    needs: [setup, build-arch-images]
    strategy:
      matrix:
        image_type: ${{ fromJson(needs.setup.outputs.image_types) }}
    runs-on: x64
    steps:
      - name: Create multi-arch manifest
        uses: IQGeo/devops-engineering-ci-public-multi-arch-action@devops/ET-734-platform-workflow
        with:
          version: ${{ inputs.version }}
          amd_tag: ${{ inputs.build_id }}_amd-64
          arm_tag: ${{ inputs.build_id }}_arm-64
          updated_tags: ${{ inputs.updated_tags }}
          module: platform/platform-${{ matrix.image_type }}
          acr: iqgeoproddev.azurecr.io
          harbor: harbor.delivery.iqgeo.cloud
          registry_username: ${{ secrets.REGISTRY_USERNAME }}
          registry_password: ${{ secrets.REGISTRY_PASSWORD }}
          harbor_cli_secret: ${{ secrets.HARBOR_CLI_SECRET }}
          harbor_username: ${{ secrets.HARBOR_USERNAME }}
          engineering_prefix: ${{ inputs.engineering_prefix }}
          releases_prefix: ${{ inputs.releases_prefix }}
          is_release: ${{ inputs.is_release }}
